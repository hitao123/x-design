/**
 * å›¾æ ‡è‡ªåŠ¨åŒ–ç”Ÿæˆç®¡çº¿
 *
 * å®Œæ•´æµç¨‹: svg/ ç›®å½•ä¸‹çš„ SVG æ–‡ä»¶ â†’ src/icons/ ä¸‹çš„ Vue ç»„ä»¶ â†’ index.ts å¯¼å‡º
 *
 * ç”¨æ³•:
 *   pnpm generate              # ä» SVG ç”Ÿæˆ Vue ç»„ä»¶ + index.ts
 *
 * è®¾è®¡å¸ˆåªéœ€è¦:
 *   1. å°† SVG æ–‡ä»¶æ”¾å…¥ svg/ ç›®å½•ï¼ˆå‘½å: kebab-caseï¼Œå¦‚ arrow-left.svgï¼‰
 *   2. æ‰§è¡Œ pnpm generate
 *   3. è‡ªåŠ¨å¾—åˆ° IconArrowLeft ç»„ä»¶å¹¶å¯¼å‡º
 *
 * å‘½åè§„åˆ™:
 *   svg æ–‡ä»¶å (kebab-case) â†’ Vue ç»„ä»¶å (PascalCase)
 *   arrow-left.svg  â†’ ArrowLeft.vue  â†’ export as IconArrowLeft
 *   close.svg       â†’ Close.vue      â†’ export as IconClose
 */
import { readdirSync, readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { resolve, basename } from 'path';
import { optimize, type Config as SvgoConfig } from 'svgo';

const SVG_DIR = resolve(__dirname, '../svg');
const ICONS_DIR = resolve(__dirname, '../src/icons');
const OUTPUT_FILE = resolve(__dirname, '../index.ts');

/** SVGO ä¼˜åŒ–é…ç½® */
const svgoConfig: SvgoConfig = {
  plugins: [
    // ä½¿ç”¨é»˜è®¤é¢„è®¾ä¼˜åŒ–
    'preset-default',
    // ç§»é™¤ SVG ä¸Šçš„å®½é«˜å±æ€§ï¼Œç”± IconWrapper æ§åˆ¶å°ºå¯¸
    'removeDimensions',
    // å°† style å±æ€§è½¬ä¸º presentation attributes
    'convertStyleToAttrs',
    // ç§»é™¤æ— ç”¨çš„å¡«å……è‰²ï¼ˆç»Ÿä¸€ç”± currentColor æ§åˆ¶ï¼‰
    {
      name: 'removeAttrs',
      params: { attrs: ['fill'] },
    },
  ],
};

/** ä½¿ç”¨ SVGO ä¼˜åŒ– SVG å†…å®¹ */
function optimizeSvg(raw: string, filename: string): string {
  const result = optimize(raw, { ...svgoConfig, path: filename });
  return result.data;
}

/** kebab-case â†’ PascalCase: "arrow-left" â†’ "ArrowLeft" */
function toPascalCase(str: string): string {
  return str
    .split('-')
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');
}

/** ä» SVG æ–‡ä»¶å†…å®¹ä¸­æå– <svg>...</svg> çš„å†…éƒ¨å†…å®¹å’Œå±æ€§ */
function parseSvg(content: string): { attrs: string; innerHTML: string } {
  // æå– <svg ...>...</svg>
  const svgMatch = content.match(/<svg([^>]*)>([\s\S]*?)<\/svg>/);
  if (!svgMatch) {
    throw new Error('Invalid SVG content');
  }

  let attrs = svgMatch[1].trim();
  const innerHTML = svgMatch[2].trim();

  // ç¡®ä¿æœ‰ xmlns
  if (!attrs.includes('xmlns=')) {
    attrs += ' xmlns="http://www.w3.org/2000/svg"';
  }

  return { attrs, innerHTML };
}

/** ç”Ÿæˆå•ä¸ª Vue å›¾æ ‡ç»„ä»¶å†…å®¹ */
function generateVueComponent(name: string, svgContent: string): string {
  const { attrs, innerHTML } = parseSvg(svgContent);

  return `<template>
  <IconWrapper v-bind="$props">
    <svg ${attrs}>
      ${innerHTML}
    </svg>
  </IconWrapper>
</template>

<script setup lang="ts">
import IconWrapper from '../components/IconWrapper.vue';
import type { IconProps } from '../types';

defineOptions({
  name: 'Icon${name}',
});

defineProps<IconProps>();
</script>
`;
}

/** ç”Ÿæˆ index.ts å¯¼å‡ºæ–‡ä»¶ */
function generateIndex(names: string[]): string {
  const iconExports = names
    .sort()
    .map((name) => `export { default as Icon${name} } from './src/icons/${name}.vue';`);

  return [
    '// âš ï¸ This file is auto-generated by scripts/generate.ts â€” DO NOT EDIT MANUALLY',
    '',
    '// Icon wrapper',
    "export { default as IconWrapper } from './src/components/IconWrapper.vue';",
    '',
    '// Icons',
    ...iconExports,
    '',
    '// Types',
    "export type { IconProps } from './src/types';",
    '',
  ].join('\n');
}

function main() {
  // ç¡®ä¿ç›®å½•å­˜åœ¨
  if (!existsSync(SVG_DIR)) {
    mkdirSync(SVG_DIR, { recursive: true });
    console.log(`ğŸ“ Created svg/ directory. Place your SVG files there.`);
    return;
  }

  if (!existsSync(ICONS_DIR)) {
    mkdirSync(ICONS_DIR, { recursive: true });
  }

  // 1. æ‰«æ SVG æ–‡ä»¶
  const svgFiles = readdirSync(SVG_DIR)
    .filter((f) => f.endsWith('.svg'))
    .sort();

  if (svgFiles.length === 0) {
    console.log('âš ï¸  No SVG files found in svg/ directory');
    return;
  }

  // 2. ä¸ºæ¯ä¸ª SVG ç”Ÿæˆ Vue ç»„ä»¶
  const componentNames: string[] = [];

  for (const file of svgFiles) {
    const kebabName = basename(file, '.svg'); // e.g. "arrow-left"
    const pascalName = toPascalCase(kebabName); // e.g. "ArrowLeft"
    const rawSvg = readFileSync(resolve(SVG_DIR, file), 'utf-8');

    // SVGO ä¼˜åŒ–
    const optimizedSvg = optimizeSvg(rawSvg, file);
    const saved = ((1 - optimizedSvg.length / rawSvg.length) * 100).toFixed(1);

    const vueContent = generateVueComponent(pascalName, optimizedSvg);
    const vueFilePath = resolve(ICONS_DIR, `${pascalName}.vue`);

    writeFileSync(vueFilePath, vueContent, 'utf-8');
    componentNames.push(pascalName);

    console.log(`  âœ… ${file} â†’ Icon${pascalName}  (${rawSvg.length}B â†’ ${optimizedSvg.length}B, -${saved}%)`);
  }

  // 3. ç”Ÿæˆ index.ts
  const indexContent = generateIndex(componentNames);
  writeFileSync(OUTPUT_FILE, indexContent, 'utf-8');

  console.log(`\nğŸ‰ Generated ${componentNames.length} icon components + index.ts`);
}

main();
